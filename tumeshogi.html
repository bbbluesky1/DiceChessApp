<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ãƒ€ã‚¤ã‚¹ãƒã‚§ã‚¹ - è©°å°†æ£‹</title>
  <style>
    /* ãƒªã‚»ãƒƒãƒˆ */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { width: 100%; height: 100%; }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: sans-serif;
      background-color: #f9f9f9;
    }
    h2 {
      margin: 16px 0;
      text-align: center;
      font-size: 1.5rem;
    }
    #controls {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
    }
    button {
      padding: 8px 12px;
      font-size: 1rem;
      border: none;
      border-radius: 4px;
      background-color: #007bff;
      color: white;
      cursor: pointer;
    }
    button:hover {
      opacity: 0.9;
    }
    /* ãƒœãƒ¼ãƒ‰ã‚’ä¸­å¤®ã«è¡¨ç¤ºã—ã€ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ã«ã‚µã‚¤ã‚ºèª¿æ•´ */
    #boardContainer,
    #userBoardWrapper {
      width: 90vw;
      max-width: 500px;
      aspect-ratio: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      margin-bottom: 16px;
    }
    table {
      width: 100%;
      height: 100%;
      border-collapse: collapse;
      table-layout: fixed;
    }
    td {
      /* å¹…ã‚’è‡ªå‹•èª¿æ•´ã—ã¦æ­£æ–¹å½¢ã«ä¿ã¤ */
      width: calc(100% / 8);
      height: calc(100% / 8);
      text-align: center;
      vertical-align: middle;
      border: 1px solid #333;
      font-weight: bold;
      font-family: monospace;
      position: relative;
    }
    .white { background-color: #eee; color: #000; }
    .black { background-color: #03d3a6ce; color: #fff; }
    /* ä»¥ä¸‹ã€æ—¢å­˜ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ãã®ã¾ã¾ç¶­æŒ */
    .legal { box-shadow: inset 0 0 0 2px limegreen; border-radius: 6px; }
    .top-label { position: absolute; bottom: 2px; right: 4px; font-size: 12px; color: green; pointer-events: none; }
    td.yellow-dot::before { content: ""; position: absolute; top: 2px; right: 2px; width: 8px; height: 8px; background-color: yellow; border-radius: 50%; pointer-events: none; z-index: 2; }
    .purple-mark::after { content: ""; position: absolute; bottom: 2px; left: 2px; width: 10px; height: 10px; background-color: purple; border-radius: 50%; pointer-events: none; z-index: 3; }
    .red-check-mark::after { content: ""; position: absolute; bottom: 2px; left: 2px; width: 10px; height: 10px; background-color: red; border-radius: 50%; pointer-events: none; z-index: 3; }
    td.selected { background-color: rgba(0, 136, 255, 0.4); }
    td.ghost { opacity: 0.4; font-style: italic; }
    .dice { width: 90%; height: 90%; max-width: 100%; max-height: 100%; position: absolute; top: 5%; left: 5%; display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); justify-items: center; align-items: center; background: #fff; border: 2px solid #000; border-radius: 6px; box-sizing: border-box; }
    .pip { width: 10px; height: 10px; background-color: #000; border-radius: 50%; }
    .ghost-wrapper { opacity: 0.5; transform: scale(0.5); filter: brightness(60%); position: absolute; width: 100%; height: 100%; top: 0; left: 0; z-index: 10; pointer-events: none; }
    .ghost-dice { border: 2px dashed #888; }
    .dice.red-dice { background-color: #e33; border-color: #a00; }
    .dice.blue-dice { background-color: #339; border-color: #004; }
    .dice.blue-dice .pip { background-color: #fff; }
    #boardContainer { display:none; }

    header {
  width: 100%;
  height: 60px;
  background-color: #222;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 20px;
  box-sizing: border-box;
  z-index: 1000;
}
#back-button {
  background: none;
  border: none;
  color: white;
  font-size: 1.2rem;
  cursor: pointer;
}
.logo {
  font-size: 1.5rem;
  font-weight: bold;
  color: white;
}
.menu-toggle {
  display: flex;
  flex-direction: column;
  gap: 4px;
  cursor: pointer;
}
.menu-toggle div {
  width: 25px;
  height: 3px;
  background-color: #fff;
}
nav {
  position: absolute;
  top: 60px;
  right: 20px;
  background-color: #444;
  display: none;
  flex-direction: column;
  min-width: 150px;
  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
  z-index: 1100;
}
nav a {
  padding: 0.8rem 1rem;
  color: #fff;
  text-decoration: none;
  border-bottom: 1px solid #555;
}
body.show-menu nav {
  display: flex;
}

  </style>
</head>
<body>
  <header>
    <button id="back-button" aria-label="æˆ»ã‚‹">â†</button>
    <div class="logo">ğŸ² DiceChess</div>
    <div class="menu-toggle" onclick="document.body.classList.toggle('show-menu')">
      <div></div><div></div><div></div>
    </div>
    <nav>
      <a href="./index.html">Home</a>
      <a href="./bot.html">Botå¯¾æˆ¦</a>
      <a href="./tutorial.html">ãƒ«ãƒ¼ãƒ«</a>
      <a href="./login.html">ã‚ªãƒ³ãƒ©ã‚¤ãƒ³å¯¾æˆ¦</a>
      <a href="./ranking.html">ãƒ©ãƒ³ã‚­ãƒ³ã‚°</a>
      <a href="./tsumeshogi.html">è©°å°†æ£‹</a>
    </nav>
  </header>

  <h2>ãƒ€ã‚¤ã‚¹ãƒã‚§ã‚¹ - è©°å°†æ£‹</h2>
  <div id="message" style="margin-bottom:16px; font-size:1rem;"></div>
  <div id="boardContainer"></div>
  <div id="userBoardWrapper"></div>
  <div id="controls">
    <button id="btnGenerate">æ¬¡ã®å•é¡Œã¸</button>
    <button id="resetButton">æœ€åˆã‹ã‚‰ã‚„ã‚Šç›´ã™</button>
  </div>
  <script>

    document.getElementById('back-button').addEventListener('click', () => {
  window.history.back();  // ã²ã¨ã¤å‰ã®ãƒšãƒ¼ã‚¸ã«æˆ»ã‚‹ï¼ˆãƒ–ãƒ©ã‚¦ã‚¶å±¥æ­´ï¼‰
});

(() => {
  const SIZE = 8;

  function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function createRandomPiece(player, isKing = false) {
    const top = getRandomInt(2, 6);
    const die = createPieceWithTop(top, player);
    return { ...die, player, isKing };
  }

  function createPieceWithTop(top, player) {
    let die;
    switch (top) {
      case 1: die = { top: 1, bottom: 6, left: 4, right: 3, front: 2, back: 5 }; break;
      case 2: die = { top: 2, bottom: 5, left: 4, right: 3, front: 6, back: 1 }; break;
      case 3: die = { top: 3, bottom: 4, left: 6, right: 1, front: 2, back: 5 }; break;
      case 4: die = { top: 4, bottom: 3, left: 1, right: 6, front: 2, back: 5 }; break;
      case 5: die = { top: 5, bottom: 2, left: 4, right: 3, front: 1, back: 6 }; break;
      case 6: die = { top: 6, bottom: 1, left: 4, right: 3, front: 5, back: 2 }; break;
    }
    if (player === "black") {
      [die.left, die.right] = [die.right, die.left];
      [die.front, die.back] = [die.back, die.front];
    }
    return die;
  }

function rollDie(die, direction) {
  const { top, bottom, front, back, left, right } = die;
  const newDie = { ...die };

  switch (direction) {
    case "up":
      newDie.top = front;
      newDie.front = bottom;
      newDie.bottom = back;
      newDie.back = top;
      break;
    case "down":
      newDie.top = back;
      newDie.back = bottom;
      newDie.bottom = front;
      newDie.front = top;
      break;
    case "left":
      newDie.top = right;
      newDie.right = bottom;
      newDie.bottom = left;
      newDie.left = top;
      break;
    case "right":
      newDie.top = left;
      newDie.left = bottom;
      newDie.bottom = right;
      newDie.right = top;
      break;
  }

  return newDie;
}



function rollDieMultiple(die, direction, times) {
  let result = JSON.parse(JSON.stringify(die)); // ã“ã“ã‚‚æ·±ã„ã‚³ãƒ”ãƒ¼ã«ã™ã‚‹
  for (let i = 0; i < times; i++) {
    result = rollDie(result, direction);
  }
  return result;
}



  function cloneBoard(board) {
    return board.map(row => row.map(cell => cell ? { ...cell } : null));
  }


function generateRandomBoard() {
  const board = Array.from({ length: SIZE }, () => Array(SIZE).fill(null));
  const occupied = new Set();

  function place(player, isKing = false, fixedTop = null) {
    while (true) {
      const r = getRandomInt(0, 7);
      const c = getRandomInt(0, 7);
      const key = r + "," + c;
      if (!occupied.has(key)) {
        let piece;
        if (isKing && fixedTop !== null) {
          // å›ºå®šã®topå€¤ã§ã‚­ãƒ³ã‚°ã‚’ä½œã‚‹
          const die = createPieceWithTop(fixedTop, player);
          piece = { ...die, player, isKing };
        } else {
          piece = createRandomPiece(player, isKing);
        }
        board[r][c] = piece;
        occupied.add(key);
        return [r, c];
      }
    }
  }

  // é»’ã‚­ãƒ³ã‚°ã¯ãƒ©ãƒ³ãƒ€ãƒ topã§é…ç½®
  place("black", true);

  // ç™½ã‚­ãƒ³ã‚°ã¯top=1ã§å›ºå®šã—ã¦é…ç½®
  place("white", true, 1);

  return board;
}


  function findBlackKing(board) {
    for (let r = 0; r < SIZE; r++)
      for (let c = 0; c < SIZE; c++) {
        const p = board[r][c];
        if (p && p.player === "black" && p.isKing) return [r, c];
      }
    return null;
  }

  function generateLegalMoves(piece, r, c, board) {
  const moves = [];
  const SIZE = 8;
  const dirs = [
    [-1, 0, "up"],
    [1, 0, "down"],
    [0, -1, "left"],
    [0, 1, "right"],
  ];

  for (const [dr, dc, dir] of dirs) {
    for (let step = 1; step <= piece.top; step++) {
      const nr = r + dr * step;
      const nc = c + dc * step;
      if (nr < 0 || nr >= SIZE || nc < 0 || nc >= SIZE) break;

      const cell = board[nr][nc];
      if (cell && typeof cell === 'object' && 'player' in cell) {
        // å‘³æ–¹é§’ã«ã¶ã¤ã‹ã£ãŸã‚‰ãã“ã¾ã§é€²ã‚ãªã„
        if (cell.player === piece.player) break;

        // æ•µé§’ï¼ˆï¼ç™½ï¼‰ã«ã¶ã¤ã‹ã£ãŸã¨ã
        if (cell.player === "white") {
          // é»’ã‚­ãƒ³ã‚°ã®å ´åˆã®ã¿ã€Œå‡ºç›®å¤§ãã„ç™½é§’ã€ã‚’å–ã‚Œã‚‹
          if (piece.player === "black" && piece.isKing) {
            if (cell.top > piece.top) {
              moves.push({ from: [r, c], to: [nr, nc], direction: dir, step });
            }
          } else {
            // é€šå¸¸ã®æ•µé§’ã¯å¸¸ã«å–ã‚Œã‚‹
            moves.push({ from: [r, c], to: [nr, nc], direction: dir, step });
          }
        }
        // ã„ãšã‚Œã«ã›ã‚ˆã€é§’ã«å½“ãŸã£ãŸã‚‰å…ˆã¸ã¯é€²ã‚ãªã„
        break;
      }

      // ç©ºãƒã‚¹ã¯å¸¸ã«é€²ã‚ã‚‹
      moves.push({ from: [r, c], to: [nr, nc], direction: dir, step });
    }
  }

  return moves;
}


 function findCheckmateUndoState(board) {
  for (let i = 0; i < SIZE; i++) {
    for (let j = 0; j < SIZE; j++) {
      const piece = board[i][j];
      if (!piece || piece.player !== "white") continue;

      const moves = generateLegalMoves(piece, i, j, board);
      for (const move of moves) {
        const newBoard = cloneBoard(board);
        newBoard[i][j] = null;

        const movedDie = rollDieMultiple(piece, move.direction, move.step);
        const [tr, tc] = move.to;
        newBoard[tr][tc] = {
          ...piece,
          ...movedDie,
          isNew: true, // ç´«ãƒãƒ¼ã‚¯
        };

        // âœ… ã“ã“ã« isBlackKingCheckmated ã‚’æŒ¿å…¥
        if (isBlackKingCheckmated(newBoard)) {
          // âœ… ã“ã“ã§ç´«ã‚’1ã¤æˆ»ã—ã¦ãƒã‚§ãƒƒã‚¯ãŒè§£é™¤ã•ã‚Œã‚‹ã‹æ¤œè¨¼
          const unsealedBoard = rewindOnePurpleMarkedPiece(newBoard);
          if (unsealedBoard && !isBlackKingCheckmated(unsealedBoard)) {
            // âœ… è©°ã¿ä¸€æ‰‹å‰ã¨ã—ã¦æˆåŠŸã—ãŸã¨è¦‹ãªã™
            return {
              originalBoard: board,
              newBoard,
              move,
              rollbackDir: move.direction,
              unsealedBoard,
            };
          }
        }
      }
    }
  }
  return null; // æ¡ä»¶ã‚’æº€ãŸã™çŠ¶æ…‹ãŒãªã‘ã‚Œã° null
}


 // highlights ã¯ [ [r, c], ... ] ã®é…åˆ—
// moveResults ã¯ [ { to: [r, c], resultTop: æ•°å­— }, ... ] ã®é…åˆ—

function calcYellowHighlights(highlights, moveResults) {
  const yellowHighlights = [];
  const seen = new Set();

  for (const [r, c] of highlights) {
    const match = moveResults.find(m => m.to[0] === r && m.to[1] === c);
    if (!match) continue;

    const top = match.resultTop;
    const range = top - 1;
    if (range <= 0) continue;

    const directions = [
      [-1, 0], // ä¸Š
      [1, 0],  // ä¸‹
      [0, -1], // å·¦
      [0, 1],  // å³
    ];

    for (const [dr, dc] of directions) {
      for (let i = 1; i <= range; i++) {
        const nr = r + dr * i;
        const nc = c + dc * i;
        if (nr < 0 || nr >= 8 || nc < 0 || nc >= 8) break;

        const key = `${nr},${nc}`;
        if (!seen.has(key)) {
          yellowHighlights.push([nr, nc]);
          seen.add(key);
        }
      }
    }
  }

  return yellowHighlights;
}

function placeWhitePieces(board, highlights, moveResults) {
  const newBoard = cloneBoard(board);
  const blackKingPos = findBlackKing(newBoard);

  for (const [r, c] of highlights) {
    const move = moveResults.find(m => m.to[0] === r && m.to[1] === c);
    if (!move) continue;

    const top = move.resultTop;
    const maxDist = top - 1;
    if (maxDist < 1) continue;

    const directions = [
      [-1, 0], // up
      [1, 0],  // down
      [0, -1], // left
      [0, 1],  // right
    ];

    const tries = shuffleArray(
      directions.flatMap(dir =>
        Array.from({ length: maxDist }, (_, i) => ({
          dr: dir[0],
          dc: dir[1],
          dist: i + 1,
        }))
      )
    );

    for (const { dr, dc, dist } of tries) {
      const fromR = r - dr * dist;
      const fromC = c - dc * dist;

      // ç¯„å›²å¤–ãƒã‚§ãƒƒã‚¯
      if (fromR < 0 || fromR >= 8 || fromC < 0 || fromC >= 8) continue;

      // â˜… ç´«é§’ã¯ legalï¼ˆç·‘æ ï¼highlightsï¼‰ã«ç½®ã‹ãªã„
      if (highlights.some(h => h[0] === fromR && h[1] === fromC)) {
        continue; // ç·‘æ ã«ã¯ç½®ã‹ãªã„
      }

      // èµ·ç‚¹ã¨é…ç½®äºˆå®šã®é–“ã«ã‚µã‚¤ã‚³ãƒ­ãŒã‚ã‚‹ã‹ç¢ºèª
      let pathClear = true;
      for (let step = 1; step < dist; step++) {
        const midR = r - dr * step;
        const midC = c - dc * step;
        if (newBoard[midR]?.[midC]) {
          pathClear = false;
          break;
        }
      }
      if (!pathClear) continue;

      // é…ç½®äºˆå®šãƒã‚¹ã«é§’ãŒã„ãªã„ã‹ç¢ºèª
      if (newBoard[fromR][fromC]) continue;

      // ç´«é§’ã‚’ç½®ã„ã¦ã¿ã‚‹
      const die = createPieceWithTop(dist, "white");
      newBoard[fromR][fromC] = {
        ...die,
        player: "white",
        isKing: false,
        isNew: true,
      };

      // â˜… ç´«é§’ã¯é»’ã‚­ãƒ³ã‚°ã«ãƒã‚§ãƒƒã‚¯ã‚’ã‹ã‘ã¦ã¯ã„ã‘ãªã„ã®ã§ãƒã‚§ãƒƒã‚¯åˆ¤å®š
      if (blackKingPos && isKingInCheck(newBoard, blackKingPos[0], blackKingPos[1])) {
        // ãƒã‚§ãƒƒã‚¯ã‹ã‘ã‚‹ãªã‚‰é…ç½®å–ã‚Šæ¶ˆã—
        newBoard[fromR][fromC] = null;
        continue; // ä»–ã®å€™è£œã‚’è©¦ã™
      }

      break; // é…ç½®æˆåŠŸã—ãŸã®ã§ãƒ«ãƒ¼ãƒ—æŠœã‘
    }
  }

  return newBoard;
}


function addCheckerToBlackKing(board) {
  const pos = findBlackKing(board);
  if (!pos) return board;
  const [kr, kc] = pos;

  const directions = shuffleArray([
    [-1, 0], [1, 0], [0, -1], [0, 1], // ä¸Šä¸‹å·¦å³ãƒ©ãƒ³ãƒ€ãƒ é †
  ]);

  const newBoard = cloneBoard(board);

  for (const [dr, dc] of directions) {
    const nr = kr + dr;
    const nc = kc + dc;

    if (nr < 0 || nr >= 8 || nc < 0 || nc >= 8) continue;
    if (newBoard[nr][nc]) continue;

    const die = createPieceWithTop(1, "white");
    newBoard[nr][nc] = {
      ...die,
      player: "white",
      isKing: false,
      isChecker: true, // â† ã“ã“ã§èµ¤ä¸¸å°ãƒ•ãƒ©ã‚°
    };

    break; // ä¸€å€‹ã ã‘è¿½åŠ 
  }

  return newBoard;
}



// é…åˆ—ã‚·ãƒ£ãƒƒãƒ•ãƒ«é–¢æ•°ï¼ˆFisherâ€“Yatesï¼‰
function shuffleArray(arr) {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}



 function createBoardTable(board, highlights = [], moveResults = [], yellowHighlights = [], isUserBoard = false, selected = null, ghostCandidates = []) {
  const table = document.createElement("table");
  table.id = "board";

  for (let r = 0; r < SIZE; r++) {
    const tr = document.createElement("tr");
    for (let c = 0; c < SIZE; c++) {
      const td = document.createElement("td");
      td.dataset.row = r;
      td.dataset.col = c;

      // ã‚»ãƒ«ã®è‰²
      td.className = (r + c) % 2 === 0 ? "white" : "black";

      const p = board[r][c];
      if (p) {
        td.appendChild(createDiceFace(p, false));
        if (p.player === "white") td.classList.add("white");
        if (p.player === "black") td.classList.add("black");
        /*
        if (p.isKing) td.classList.add("king");
        if (p.isNew && p.player === "white") td.classList.add("purple-mark");
        if (p.isChecker && p.player === "white") td.classList.add("red-check-mark");
        */
      }

      // ã‚´ãƒ¼ã‚¹ãƒˆå€™è£œãŒã‚ã‚‹å ´åˆ
      const ghost = ghostCandidates.find(g => g.row === r && g.col === c);
      if (ghost) {
        const ghostWrapper = document.createElement("div");
        ghostWrapper.className = "ghost-wrapper";
        const ghostDice = createDiceFace(ghost.piece, true);
        ghostWrapper.appendChild(ghostDice);
        td.appendChild(ghostWrapper);
      }

      // ãƒã‚¤ãƒ©ã‚¤ãƒˆ
      if (highlights.some(h => h[0] === r && h[1] === c)) {
        td.classList.add("legal");
      }

      if (yellowHighlights.some(h => h[0] === r && h[1] === c)) {
        td.classList.add("yellow-dot");
      }

      if (selected && selected.row === r && selected.col === c) {
        td.classList.add("selected");
      }

      // è©•ä¾¡ãƒ©ãƒ™ãƒ«
      const result = moveResults.find(m => m.to[0] === r && m.to[1] === c);
      if (result) {
        const label = document.createElement("div");
        label.className = "top-label";
        label.textContent = result.resultTop;
        td.appendChild(label);
      }

      // ã‚¯ãƒªãƒƒã‚¯å‡¦ç†
      if (isUserBoard) {
        td.addEventListener("click", () => {
          handleUserClick(r, c);
        });
      }

      tr.appendChild(td);
    }
    table.appendChild(tr);
  }

  return table;
}

// pipé…ç½®ï¼ˆã‚µã‚¤ã‚³ãƒ­ã®ç›®ï¼‰ã‚’3x3ã®ä½ç½®ã§è¡¨ç¾
const pipPositions = {
  1: [4],
  2: [0, 8],
  3: [0, 4, 8],
  4: [0, 2, 6, 8],
  5: [0, 2, 4, 6, 8],
  6: [0, 2, 3, 5, 6, 8],
};

function createDiceFace(piece, isGhost = false) {
  const face = document.createElement("div");
  face.className = isGhost ? "dice ghost-dice" : "dice";

  if (piece.isKing) {
    face.classList.add("king");
    if (piece.player === "white") {
      face.classList.add("red-dice");
    } else if (piece.player === "black") {
      face.classList.add("blue-dice");
    }
  }

  const pipIndices = pipPositions[piece.top] || [];
  for (let i = 0; i < 9; i++) {
    const cell = document.createElement("div");
    if (pipIndices.includes(i)) {
      const pip = document.createElement("div");
      pip.className = "pip";
      cell.appendChild(pip);
    }
    face.appendChild(cell);
  }

  return face;
}




let currentUserBoard = null;
let targetAnswerBoard = null;

function deepCopyBoard(board) {
  return board.map(row =>
    row.map(cell => cell ? { ...cell } : null)
  );
}

function compareBoards(b1, b2) {
  for (let r = 0; r < SIZE; r++) {
    for (let c = 0; c < SIZE; c++) {
      const cell1 = b1[r][c];
      const cell2 = b2[r][c];

      if (!cell1 && !cell2) continue;
      if (!cell1 || !cell2) return false;

      if (
        cell1.top !== cell2.top ||
        cell1.player !== cell2.player ||
        cell1.isKing !== cell2.isKing
      ) {
        return false;
      }
    }
  }
  return true;
}


function getDirection(from, to) {
  if (to.col === from.col) {
    if (to.row < from.row) return "up";
    if (to.row > from.row) return "down";
  } else if (to.row === from.row) {
    if (to.col < from.col) return "left";
    if (to.col > from.col) return "right";
  }
  return null; // æ–œã‚ã‚„ä¸æ­£ç§»å‹•ã¯null
}

let selectedCell = null;
let moveCandidates = []; // ç§»å‹•å¯èƒ½ãƒã‚¹ã¨å›è»¢å¾Œã®çŠ¶æ…‹ã‚’ä¿å­˜

function handleUserClick(row, col) {
  const msg = document.getElementById("message");
  const cell = currentUserBoard[row][col];
  const wrapper = document.getElementById("userBoardWrapper");

  if (!selectedCell) {
    // é§’ã‚’é¸æŠã™ã‚‹ãƒ•ã‚§ãƒ¼ã‚º
    if (cell && cell.player === "white") {
      selectedCell = { row, col };

      // ã‚´ãƒ¼ã‚¹ãƒˆã‚’è¡¨ç¤ºï¼ˆä¸Šä¸‹å·¦å³æ–¹å‘ã§ç©ºãƒã‚¹ã ã‘ï¼‰
      const moveCandidates = [];
      const directions = ["up", "down", "left", "right"];

      for (const dir of directions) {
        let step = 1;
        while (true) {
          const targetRow = dir === "up" ? row - step :
                            dir === "down" ? row + step : row;
          const targetCol = dir === "left" ? col - step :
                            dir === "right" ? col + step : col;

          if (targetRow < 0 || targetRow >= SIZE || targetCol < 0 || targetCol >= SIZE)
            break;

          if (currentUserBoard[targetRow][targetCol] !== null)
            break;

          const ghost = rollDieMultiple(cell, dir, step);
          moveCandidates.push({
            row: targetRow,
            col: targetCol,
            piece: ghost
          });

          step++;
        }
      }

      // ã‚´ãƒ¼ã‚¹ãƒˆä»˜ãã§æç”»
      wrapper.innerHTML = "";
      wrapper.appendChild(createBoardTable(currentUserBoard, [], [], [], true, selectedCell, moveCandidates));
    } else {
      // ç™½é§’ã˜ã‚ƒãªã‹ã£ãŸã‚‰ä½•ã‚‚ã—ãªã„ã€ã‚´ãƒ¼ã‚¹ãƒˆã‚‚æ¶ˆã™
      selectedCell = null;
      wrapper.innerHTML = "";
      wrapper.appendChild(createBoardTable(currentUserBoard, [], [], [], true, null, []));
    }

    return;
  }

  // ç§»å‹•å…ˆé¸æŠãƒ•ã‚§ãƒ¼ã‚º
  const from = selectedCell;
  const to = { row, col };
  selectedCell = null;

  const movingPiece = currentUserBoard[from.row][from.col];
  if (!movingPiece) return;

  const direction = getDirection(from, to);
  if (!direction) {
    //msg.textContent = "ãã®æ–¹å‘ã«ã¯ç§»å‹•ã§ãã¾ã›ã‚“ã€‚";
    wrapper.innerHTML = "";
    wrapper.appendChild(createBoardTable(currentUserBoard, [], [], [], true, null, []));
    return;
  }

  const times = Math.abs(direction === "up" || direction === "down"
                         ? to.row - from.row
                         : to.col - from.col);

  // ç›®çš„åœ°ãŒç©ºã§ãªã‘ã‚Œã°ã‚­ãƒ£ãƒ³ã‚»ãƒ«
  if (currentUserBoard[to.row][to.col] !== null) {
    //msg.textContent = "ãã“ã«ã¯ç§»å‹•ã§ãã¾ã›ã‚“ã€‚";
    wrapper.innerHTML = "";
    wrapper.appendChild(createBoardTable(currentUserBoard, [], [], [], true, null, []));
    return;
  }

  // å›è»¢ã—ã¦ç§»å‹•
  const rotatedPiece = rollDieMultiple(movingPiece, direction, times);
  currentUserBoard[to.row][to.col] = rotatedPiece;
  currentUserBoard[from.row][from.col] = null;

  // å†æç”»ï¼ˆé¸æŠè§£é™¤ + ã‚´ãƒ¼ã‚¹ãƒˆãªã—ï¼‰
  wrapper.innerHTML = "";
  wrapper.appendChild(createBoardTable(currentUserBoard, [], [], [], true, null, []));

  // æ­£èª¤ãƒã‚§ãƒƒã‚¯
  if (compareBoards(currentUserBoard, targetAnswerBoard)) {
    msg.textContent = "æ­£è§£ã§ã™ï¼ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ ğŸ‰";
  } else {
    msg.textContent = "ä¸æ­£è§£ã§ã™ã€‚ã‚‚ã†ä¸€åº¦è©¦ã—ã¦ã¿ã¦ãã ã•ã„ã€‚";
  }
}






function removeUnmarkedWhitePieces(board) {
  const newBoard = cloneBoard(board);
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const piece = newBoard[r][c];
      if (
        piece &&
        piece.player === "white" &&
        !piece.isKing &&
        !piece.isNew
      ) {
        newBoard[r][c] = null;
      }
    }
  }
  return newBoard;
}


function neutralizeThreatsToWhiteKing(board) {
  const newBoard = cloneBoard(board);

  let kingPos = null;
  let kingTop = null;

  // ç™½ã‚­ãƒ³ã‚°ã®ä½ç½®ã¨topã‚’æ¢ã™
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const piece = newBoard[r][c];
      if (piece && piece.player === "white" && piece.isKing) {
        kingPos = [r, c];
        kingTop = piece.top;
        break;
      }
    }
    if (kingPos) break;
  }

  if (!kingPos) return newBoard;

  const directions = [
    [-1, 0], [1, 0], [0, -1], [0, 1], // ä¸Šä¸‹å·¦å³
  ];

  for (const [dr, dc] of directions) {
    for (let dist = 1; dist <= kingTop; dist++) {
      const nr = kingPos[0] + dr * dist;
      const nc = kingPos[1] + dc * dist;
      if (nr < 0 || nr >= 8 || nc < 0 || nc >= 8) break;

      const target = newBoard[nr][nc];
      if (!target) continue;
      if (target.player !== "black") break;

      if (target.top < kingTop) {
        if (kingTop < 6) {
          // å¼·åŒ–ï¼štopã‚’ç™½ã‚­ãƒ³ã‚°top+1ã«å¤‰æ›´
          const newTop = kingTop + 1;
          const newDie = createPieceWithTop(newTop, "black");
          newBoard[nr][nc] = { ...target, ...newDie };
        } else {
          // ç™½ã‚­ãƒ³ã‚°top==6 ã®å ´åˆã¯å‰Šé™¤
          newBoard[nr][nc] = null;
        }
      }
      break; // æœ€åˆã«å½“ãŸã£ãŸé§’ã ã‘ãƒã‚§ãƒƒã‚¯
    }
  }

  return newBoard;
}

function rewindOnePurpleMarkedPiece(board) {
  const newBoard = cloneBoard(board);

  for (let r = 0; r < SIZE; r++) {
    for (let c = 0; c < SIZE; c++) {
      const piece = newBoard[r][c];
      if (!piece || piece.player !== "white" || !piece.isNew) continue;

      const directions = [
        [-1, 0, "up"],
        [1, 0, "down"],
        [0, -1, "left"],
        [0, 1, "right"]
      ];

      for (const [dr, dc, dir] of directions) {
        const nr = r + dr * piece.top;
        const nc = c + dc * piece.top;

        if (nr < 0 || nr >= SIZE || nc < 0 || nc >= SIZE) continue;
        if (newBoard[nr][nc]) continue;

        // ä¸€æ‰‹æˆ»ã™ï¼šå…ƒã®ä½ç½®ã‹ã‚‰é™¤ãã€æ–°ã—ã„ä½ç½®ã«å†é…ç½®ï¼ˆtopæ–¹å‘ã‚’æˆ»ã™ï¼‰
        const rewoundDie = rollDieMultiple(piece, dir, piece.top);
        newBoard[r][c] = null;
        newBoard[nr][nc] = {
          ...piece,
          ...rewoundDie,
          isNew: false // ç´«ãƒãƒ¼ã‚¯é™¤å»
        };

        return newBoard; // ä¸€ã¤ã ã‘å‡¦ç†ã—ã¦çµ‚äº†
      }
    }
  }

  return null;
}


function isBlackKingCheckmated(board) {
  const kingPos = findBlackKing(board);
  if (!kingPos) return false;

  const [kr, kc] = kingPos;
  const king = board[kr][kc];
  if (!king) return false;

  const moves = generateLegalMoves(king, kr, kc, board);
  for (const move of moves) {
    const testBoard = cloneBoard(board);
    testBoard[kr][kc] = null;
    const movedDie = rollDieMultiple(king, move.direction, move.step);
    testBoard[move.to[0]][move.to[1]] = { ...king, ...movedDie };

    if (!isKingInCheck(testBoard, move.to[0], move.to[1])) {
      return false; // é€ƒã’é“ãŒã‚ã‚‹ã®ã§è©°ã¿ã§ãªã„
    }
  }

  return true; // ã™ã¹ã¦ã®ç§»å‹•å…ˆãŒãƒã‚§ãƒƒã‚¯ã•ã‚Œã¦ã„ã‚‹
}

function isKingInCheck(board, r, c) {
  const king = board[r][c];
  if (!king || !king.isKing || king.player !== "black") return false;

  for (let i = 0; i < SIZE; i++) {
    for (let j = 0; j < SIZE; j++) {
      const piece = board[i][j];
      if (!piece || piece.player !== "white") continue;

      const moves = generateLegalMoves(piece, i, j, board);
      for (const move of moves) {
        const [tr, tc] = move.to;
        if (tr === r && tc === c && piece.top < king.top) {
          return true;
        }
      }
    }
  }

  return false;
}


  // â–  ç´«é§’ã‚’ï¼‘ã¤ã ã‘è¿½åŠ ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼
  function placeWhitePiecesForOne(board, highlights, moveResults, blackKingTop) {
    const newBoard = cloneBoard(board);
    for (const [r, c] of highlights) {
      const move = moveResults.find(m => m.to[0] === r && m.to[1] === c);
      if (!move) continue;
      const top = move.resultTop;
      if (top === 1 && top <= blackKingTop && !newBoard[r][c]) {
        const die = createPieceWithTop(blackKingTop, "white");
        newBoard[r][c] = { ...die, player: "white", isKing: false, isNew: true };
        break;  // ï¼‘ã¤ã ã‘ç½®ã„ã¦æŠœã‘ã‚‹
      }
    }
    return newBoard;
  }


// board1 ã¨ board2 ã‚’ãƒãƒ¼ã‚¸ã—ã¦ã€board2 ã® isNew é§’ã ã‘ã‚’é‡ã­ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼
function mergeBoards(board1, board2) {
  const merged = board1.map(row => row.map(cell => cell ? { ...cell } : null));
  for (let r = 0; r < SIZE; r++) {
    for (let c = 0; c < SIZE; c++) {
      const p2 = board2[r][c];
      if (p2 && p2.isNew) {
        merged[r][c] = { ...p2 };
      }
    }
  }
  return merged;
}
/*
function getOppositeDirection(dir) {
  return { up: "down", down: "up", left: "right", right: "left" }[dir];
}
  */

function generateReversedCheckerBoard(board, blackKingTop) {
  const newBoard = cloneBoard(board);

  for (let r = 0; r < SIZE; r++) {
    for (let c = 0; c < SIZE; c++) {
      const piece = newBoard[r][c];
      if (piece && piece.isChecker && piece.player === "white") {
        const directions = ["up", "down", "left", "right"];
        for (const dir of directions) {
          const dr = dir === "up" ? -1 : dir === "down" ? 1 : 0;
          const dc = dir === "left" ? -1 : dir === "right" ? 1 : 0;

          for (let step = 1; step <= 6; step++) {
            const fromR = r + dr * step;
            const fromC = c + dc * step;

            if (fromR < 0 || fromR >= SIZE || fromC < 0 || fromC >= SIZE) break;

            // é£›ã³è¶Šãˆç¦æ­¢ãƒã‚§ãƒƒã‚¯
            let blocked = false;
            for (let i = 1; i <= step; i++) {
              const midR = r + dr * i;
              const midC = c + dc * i;
              if (newBoard[midR][midC] && !(i === step && newBoard[midR][midC] === null)) {
                blocked = true;
                break;
              }
            }
            if (blocked) continue;

            if (newBoard[fromR][fromC]) continue;

            /*const oppositeDir = getOppositeDirection(dir);*/
            const rewoundDie = rollDieMultiple(piece,dir, step);

            // topãŒé»’ã‚­ãƒ³ã‚°topæœªæº€ãªã‚‰ã‚¹ã‚­ãƒƒãƒ—
            if (rewoundDie.top < blackKingTop) continue;

            newBoard[r][c] = null;
            newBoard[fromR][fromC] = {
              ...piece,
              ...rewoundDie,
              isChecker: true
            };
            return newBoard;
          }
        }
      }
    }
  }

  return newBoard;
}


document.getElementById("resetButton").addEventListener("click", () => {
  if (!initialUserBoard) return; // å¿µã®ãŸã‚åˆæœŸçŠ¶æ…‹ãŒã‚ã‚‹ã‹ç¢ºèª

  currentUserBoard = deepCopyBoard(initialUserBoard);

  // è¡¨ç¤ºã‚’æ›´æ–°
  const userBoardEl = createBoardTable(currentUserBoard, [], [], [], true);
  const wrapper = document.getElementById("userBoardWrapper");
  wrapper.innerHTML = "";
  wrapper.appendChild(userBoardEl);

  // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãªã©ã‚ã‚Œã°ãƒªã‚»ãƒƒãƒˆå¯èƒ½
  const msg = document.getElementById("message");
  msg.textContent = "ä¸€æ‰‹ã§é»’ã‚’ãƒã‚§ãƒƒã‚¯ãƒ¡ã‚¤ãƒˆ";
});


let initialUserBoard = null;

async function searchUntilFound() {
  const msg = document.getElementById("message");
  const container = document.getElementById("boardContainer");
  container.innerHTML = "";
  msg.textContent = "æ–°ã—ã„å•é¡Œã‚’ç”Ÿæˆä¸­â€¦";

  let trials = 0;
  while (true) {
    const board0 = generateRandomBoard();

    // ğŸ” é»’ã‚­ãƒ³ã‚°ã®ä½ç½®ã‚’ç¢ºèªã—ã¦ã€å­˜åœ¨ã—ãªã‘ã‚Œã°ã‚¹ã‚­ãƒƒãƒ—
    const pos = findBlackKing(board0);
    if (!pos) continue;

    // âœ… é»’ã‚­ãƒ³ã‚°ã«ãƒã‚§ãƒƒã‚¯ã‚’ã‹ã‘ã‚‹ç™½ãƒ€ã‚¤ã‚¹ã‚’è¿½åŠ 
    const board = addCheckerToBlackKing(board0);

    // âœ… è©°ã¿ä¸€æ‰‹å‰çŠ¶æ…‹ã®æ¢ç´¢
    const result = findCheckmateUndoState(board);
    trials++;
    if (!result) {
      if (trials % 100 === 0) await new Promise(r => setTimeout(r, 10));
      continue;
    }

    //msg.textContent = `æˆåŠŸï¼ï¼ˆ${trials} å›ï¼‰`;
    msg.textContent = "ä¸€æ‰‹ã§é»’ã‚’ãƒã‚§ãƒƒã‚¯ãƒ¡ã‚¤ãƒˆ";

    const board1 = result.originalBoard;

    // â†“ ã“ã®ã‚ã¨ã®å‡¦ç†ã¯ãã®ã¾ã¾ã§OK
    const [kr, kc] = findBlackKing(board1);
    const blackKing = board1[kr][kc];
    const blackKingTop = blackKing.top;

    const kingMoves = generateLegalMoves(blackKing, kr, kc, board1);
    const highlights  = kingMoves.map(m => m.to);
    const moveResults = kingMoves.map(m => ({
      to: m.to,
      resultTop: rollDieMultiple(blackKing, m.direction, m.step).top
    }));

    // âœ… ã“ã“ã§ãƒã‚§ãƒƒã‚¯ï¼štop=1 ã®ãƒã‚¹ãŒã‚ã‚Œã°æ¢ç´¢ã‚„ã‚Šç›´ã—
    if (moveResults.some(m => m.resultTop === 1)) continue;

    const yellowHighlights = calcYellowHighlights(highlights, moveResults);

    let board2 = cloneBoard(board1);
    board2 = placeWhitePieces(board2, highlights, moveResults);
    board2 = removeUnmarkedWhitePieces(board2);
    board2 = neutralizeThreatsToWhiteKing(board2);

    const mergedBoard = mergeBoards(board1, board2);
/*
    container.appendChild(createBoardTable(
      mergedBoard,
      highlights,
      moveResults,
      yellowHighlights
    ));
*/
const blackKingPos = findBlackKing(board);
const black_KingTop = blackKingPos ? board[blackKingPos[0]][blackKingPos[1]].top : 1;
const reversedBoard = generateReversedCheckerBoard(mergedBoard, black_KingTop);
/*
container.appendChild(document.createElement("hr"));
container.appendChild(document.createTextNode("â† èµ¤ãƒã‚§ãƒƒã‚¯ãƒãƒ¼ã‚¯ã®ã‚µã‚¤ã‚³ãƒ­ã‚’é€†å›è»¢ã•ã›ãŸç›¤é¢"));
container.appendChild(createBoardTable(reversedBoard));
*/

currentUserBoard = deepCopyBoard(reversedBoard);
initialUserBoard = deepCopyBoard(reversedBoard); // åˆæœŸçŠ¶æ…‹ã‚’ä¿å­˜
targetAnswerBoard = deepCopyBoard(mergedBoard);

const userBoardEl = createBoardTable(currentUserBoard, [], [], [], true);
const answerBoardEl = createBoardTable(targetAnswerBoard, [], [], [], false);

document.getElementById("userBoardWrapper").innerHTML = "";
document.getElementById("userBoardWrapper").appendChild(userBoardEl);




    break;
  }
}


document.addEventListener("DOMContentLoaded", () => {
  searchUntilFound();

  document.getElementById("btnGenerate").addEventListener("click", searchUntilFound);
});


})();
</script>
</body>
</html>
