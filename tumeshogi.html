<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ダイスチェス - 詰将棋</title>
  <style>
    /* リセット */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { width: 100%; height: 100%; }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: sans-serif;
      background-color: #f9f9f9;
    }
    h2 {
      margin: 16px 0;
      text-align: center;
      font-size: 1.5rem;
    }
    #controls {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
    }
    button {
      padding: 8px 12px;
      font-size: 1rem;
      border: none;
      border-radius: 4px;
      background-color: #007bff;
      color: white;
      cursor: pointer;
    }
    button:hover {
      opacity: 0.9;
    }
    /* ボードを中央に表示し、レスポンシブにサイズ調整 */
    #boardContainer,
    #userBoardWrapper {
      width: 90vw;
      max-width: 500px;
      aspect-ratio: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      margin-bottom: 16px;
    }
    table {
      width: 100%;
      height: 100%;
      border-collapse: collapse;
      table-layout: fixed;
    }
    td {
      /* 幅を自動調整して正方形に保つ */
      width: calc(100% / 8);
      height: calc(100% / 8);
      text-align: center;
      vertical-align: middle;
      border: 1px solid #333;
      font-weight: bold;
      font-family: monospace;
      position: relative;
    }
    .white { background-color: #eee; color: #000; }
    .black { background-color: #03d3a6ce; color: #fff; }
    /* 以下、既存スタイルをそのまま維持 */
    .legal { box-shadow: inset 0 0 0 2px limegreen; border-radius: 6px; }
    .top-label { position: absolute; bottom: 2px; right: 4px; font-size: 12px; color: green; pointer-events: none; }
    td.yellow-dot::before { content: ""; position: absolute; top: 2px; right: 2px; width: 8px; height: 8px; background-color: yellow; border-radius: 50%; pointer-events: none; z-index: 2; }
    .purple-mark::after { content: ""; position: absolute; bottom: 2px; left: 2px; width: 10px; height: 10px; background-color: purple; border-radius: 50%; pointer-events: none; z-index: 3; }
    .red-check-mark::after { content: ""; position: absolute; bottom: 2px; left: 2px; width: 10px; height: 10px; background-color: red; border-radius: 50%; pointer-events: none; z-index: 3; }
    td.selected { background-color: rgba(0, 136, 255, 0.4); }
    td.ghost { opacity: 0.4; font-style: italic; }
    .dice { width: 90%; height: 90%; max-width: 100%; max-height: 100%; position: absolute; top: 5%; left: 5%; display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); justify-items: center; align-items: center; background: #fff; border: 2px solid #000; border-radius: 6px; box-sizing: border-box; }
    .pip { width: 10px; height: 10px; background-color: #000; border-radius: 50%; }
    .ghost-wrapper { opacity: 0.5; transform: scale(0.5); filter: brightness(60%); position: absolute; width: 100%; height: 100%; top: 0; left: 0; z-index: 10; pointer-events: none; }
    .ghost-dice { border: 2px dashed #888; }
    .dice.red-dice { background-color: #e33; border-color: #a00; }
    .dice.blue-dice { background-color: #339; border-color: #004; }
    .dice.blue-dice .pip { background-color: #fff; }
    #boardContainer { display:none; }

    header {
  width: 100%;
  height: 60px;
  background-color: #222;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 20px;
  box-sizing: border-box;
  z-index: 1000;
}
#back-button {
  background: none;
  border: none;
  color: white;
  font-size: 1.2rem;
  cursor: pointer;
}
.logo {
  font-size: 1.5rem;
  font-weight: bold;
  color: white;
}
.menu-toggle {
  display: flex;
  flex-direction: column;
  gap: 4px;
  cursor: pointer;
}
.menu-toggle div {
  width: 25px;
  height: 3px;
  background-color: #fff;
}
nav {
  position: absolute;
  top: 60px;
  right: 20px;
  background-color: #444;
  display: none;
  flex-direction: column;
  min-width: 150px;
  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
  z-index: 1100;
}
nav a {
  padding: 0.8rem 1rem;
  color: #fff;
  text-decoration: none;
  border-bottom: 1px solid #555;
}
body.show-menu nav {
  display: flex;
}

  </style>
</head>
<body>
  <header>
    <button id="back-button" aria-label="戻る">←</button>
    <div class="logo">🎲 DiceChess</div>
    <div class="menu-toggle" onclick="document.body.classList.toggle('show-menu')">
      <div></div><div></div><div></div>
    </div>
    <nav>
      <a href="./index.html">Home</a>
      <a href="./bot.html">Bot対戦</a>
      <a href="./tutorial.html">ルール</a>
      <a href="./login.html">オンライン対戦</a>
      <a href="./ranking.html">ランキング</a>
      <a href="./tsumeshogi.html">詰将棋</a>
    </nav>
  </header>

  <h2>ダイスチェス - 詰将棋</h2>
  <div id="message" style="margin-bottom:16px; font-size:1rem;"></div>
  <div id="boardContainer"></div>
  <div id="userBoardWrapper"></div>
  <div id="controls">
    <button id="btnGenerate">次の問題へ</button>
    <button id="resetButton">最初からやり直す</button>
  </div>
  <script>

    document.getElementById('back-button').addEventListener('click', () => {
  window.history.back();  // ひとつ前のページに戻る（ブラウザ履歴）
});

(() => {
  const SIZE = 8;

  function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function createRandomPiece(player, isKing = false) {
    const top = getRandomInt(2, 6);
    const die = createPieceWithTop(top, player);
    return { ...die, player, isKing };
  }

  function createPieceWithTop(top, player) {
    let die;
    switch (top) {
      case 1: die = { top: 1, bottom: 6, left: 4, right: 3, front: 2, back: 5 }; break;
      case 2: die = { top: 2, bottom: 5, left: 4, right: 3, front: 6, back: 1 }; break;
      case 3: die = { top: 3, bottom: 4, left: 6, right: 1, front: 2, back: 5 }; break;
      case 4: die = { top: 4, bottom: 3, left: 1, right: 6, front: 2, back: 5 }; break;
      case 5: die = { top: 5, bottom: 2, left: 4, right: 3, front: 1, back: 6 }; break;
      case 6: die = { top: 6, bottom: 1, left: 4, right: 3, front: 5, back: 2 }; break;
    }
    if (player === "black") {
      [die.left, die.right] = [die.right, die.left];
      [die.front, die.back] = [die.back, die.front];
    }
    return die;
  }

function rollDie(die, direction) {
  const { top, bottom, front, back, left, right } = die;
  const newDie = { ...die };

  switch (direction) {
    case "up":
      newDie.top = front;
      newDie.front = bottom;
      newDie.bottom = back;
      newDie.back = top;
      break;
    case "down":
      newDie.top = back;
      newDie.back = bottom;
      newDie.bottom = front;
      newDie.front = top;
      break;
    case "left":
      newDie.top = right;
      newDie.right = bottom;
      newDie.bottom = left;
      newDie.left = top;
      break;
    case "right":
      newDie.top = left;
      newDie.left = bottom;
      newDie.bottom = right;
      newDie.right = top;
      break;
  }

  return newDie;
}



function rollDieMultiple(die, direction, times) {
  let result = JSON.parse(JSON.stringify(die)); // ここも深いコピーにする
  for (let i = 0; i < times; i++) {
    result = rollDie(result, direction);
  }
  return result;
}



  function cloneBoard(board) {
    return board.map(row => row.map(cell => cell ? { ...cell } : null));
  }


function generateRandomBoard() {
  const board = Array.from({ length: SIZE }, () => Array(SIZE).fill(null));
  const occupied = new Set();

  function place(player, isKing = false, fixedTop = null) {
    while (true) {
      const r = getRandomInt(0, 7);
      const c = getRandomInt(0, 7);
      const key = r + "," + c;
      if (!occupied.has(key)) {
        let piece;
        if (isKing && fixedTop !== null) {
          // 固定のtop値でキングを作る
          const die = createPieceWithTop(fixedTop, player);
          piece = { ...die, player, isKing };
        } else {
          piece = createRandomPiece(player, isKing);
        }
        board[r][c] = piece;
        occupied.add(key);
        return [r, c];
      }
    }
  }

  // 黒キングはランダムtopで配置
  place("black", true);

  // 白キングはtop=1で固定して配置
  place("white", true, 1);

  return board;
}


  function findBlackKing(board) {
    for (let r = 0; r < SIZE; r++)
      for (let c = 0; c < SIZE; c++) {
        const p = board[r][c];
        if (p && p.player === "black" && p.isKing) return [r, c];
      }
    return null;
  }

  function generateLegalMoves(piece, r, c, board) {
  const moves = [];
  const SIZE = 8;
  const dirs = [
    [-1, 0, "up"],
    [1, 0, "down"],
    [0, -1, "left"],
    [0, 1, "right"],
  ];

  for (const [dr, dc, dir] of dirs) {
    for (let step = 1; step <= piece.top; step++) {
      const nr = r + dr * step;
      const nc = c + dc * step;
      if (nr < 0 || nr >= SIZE || nc < 0 || nc >= SIZE) break;

      const cell = board[nr][nc];
      if (cell && typeof cell === 'object' && 'player' in cell) {
        // 味方駒にぶつかったらそこまで進めない
        if (cell.player === piece.player) break;

        // 敵駒（＝白）にぶつかったとき
        if (cell.player === "white") {
          // 黒キングの場合のみ「出目大きい白駒」を取れる
          if (piece.player === "black" && piece.isKing) {
            if (cell.top > piece.top) {
              moves.push({ from: [r, c], to: [nr, nc], direction: dir, step });
            }
          } else {
            // 通常の敵駒は常に取れる
            moves.push({ from: [r, c], to: [nr, nc], direction: dir, step });
          }
        }
        // いずれにせよ、駒に当たったら先へは進めない
        break;
      }

      // 空マスは常に進める
      moves.push({ from: [r, c], to: [nr, nc], direction: dir, step });
    }
  }

  return moves;
}


 function findCheckmateUndoState(board) {
  for (let i = 0; i < SIZE; i++) {
    for (let j = 0; j < SIZE; j++) {
      const piece = board[i][j];
      if (!piece || piece.player !== "white") continue;

      const moves = generateLegalMoves(piece, i, j, board);
      for (const move of moves) {
        const newBoard = cloneBoard(board);
        newBoard[i][j] = null;

        const movedDie = rollDieMultiple(piece, move.direction, move.step);
        const [tr, tc] = move.to;
        newBoard[tr][tc] = {
          ...piece,
          ...movedDie,
          isNew: true, // 紫マーク
        };

        // ✅ ここに isBlackKingCheckmated を挿入
        if (isBlackKingCheckmated(newBoard)) {
          // ✅ ここで紫を1つ戻してチェックが解除されるか検証
          const unsealedBoard = rewindOnePurpleMarkedPiece(newBoard);
          if (unsealedBoard && !isBlackKingCheckmated(unsealedBoard)) {
            // ✅ 詰み一手前として成功したと見なす
            return {
              originalBoard: board,
              newBoard,
              move,
              rollbackDir: move.direction,
              unsealedBoard,
            };
          }
        }
      }
    }
  }
  return null; // 条件を満たす状態がなければ null
}


 // highlights は [ [r, c], ... ] の配列
// moveResults は [ { to: [r, c], resultTop: 数字 }, ... ] の配列

function calcYellowHighlights(highlights, moveResults) {
  const yellowHighlights = [];
  const seen = new Set();

  for (const [r, c] of highlights) {
    const match = moveResults.find(m => m.to[0] === r && m.to[1] === c);
    if (!match) continue;

    const top = match.resultTop;
    const range = top - 1;
    if (range <= 0) continue;

    const directions = [
      [-1, 0], // 上
      [1, 0],  // 下
      [0, -1], // 左
      [0, 1],  // 右
    ];

    for (const [dr, dc] of directions) {
      for (let i = 1; i <= range; i++) {
        const nr = r + dr * i;
        const nc = c + dc * i;
        if (nr < 0 || nr >= 8 || nc < 0 || nc >= 8) break;

        const key = `${nr},${nc}`;
        if (!seen.has(key)) {
          yellowHighlights.push([nr, nc]);
          seen.add(key);
        }
      }
    }
  }

  return yellowHighlights;
}

function placeWhitePieces(board, highlights, moveResults) {
  const newBoard = cloneBoard(board);
  const blackKingPos = findBlackKing(newBoard);

  for (const [r, c] of highlights) {
    const move = moveResults.find(m => m.to[0] === r && m.to[1] === c);
    if (!move) continue;

    const top = move.resultTop;
    const maxDist = top - 1;
    if (maxDist < 1) continue;

    const directions = [
      [-1, 0], // up
      [1, 0],  // down
      [0, -1], // left
      [0, 1],  // right
    ];

    const tries = shuffleArray(
      directions.flatMap(dir =>
        Array.from({ length: maxDist }, (_, i) => ({
          dr: dir[0],
          dc: dir[1],
          dist: i + 1,
        }))
      )
    );

    for (const { dr, dc, dist } of tries) {
      const fromR = r - dr * dist;
      const fromC = c - dc * dist;

      // 範囲外チェック
      if (fromR < 0 || fromR >= 8 || fromC < 0 || fromC >= 8) continue;

      // ★ 紫駒は legal（緑枠＝highlights）に置かない
      if (highlights.some(h => h[0] === fromR && h[1] === fromC)) {
        continue; // 緑枠には置かない
      }

      // 起点と配置予定の間にサイコロがあるか確認
      let pathClear = true;
      for (let step = 1; step < dist; step++) {
        const midR = r - dr * step;
        const midC = c - dc * step;
        if (newBoard[midR]?.[midC]) {
          pathClear = false;
          break;
        }
      }
      if (!pathClear) continue;

      // 配置予定マスに駒がいないか確認
      if (newBoard[fromR][fromC]) continue;

      // 紫駒を置いてみる
      const die = createPieceWithTop(dist, "white");
      newBoard[fromR][fromC] = {
        ...die,
        player: "white",
        isKing: false,
        isNew: true,
      };

      // ★ 紫駒は黒キングにチェックをかけてはいけないのでチェック判定
      if (blackKingPos && isKingInCheck(newBoard, blackKingPos[0], blackKingPos[1])) {
        // チェックかけるなら配置取り消し
        newBoard[fromR][fromC] = null;
        continue; // 他の候補を試す
      }

      break; // 配置成功したのでループ抜け
    }
  }

  return newBoard;
}


function addCheckerToBlackKing(board) {
  const pos = findBlackKing(board);
  if (!pos) return board;
  const [kr, kc] = pos;

  const directions = shuffleArray([
    [-1, 0], [1, 0], [0, -1], [0, 1], // 上下左右ランダム順
  ]);

  const newBoard = cloneBoard(board);

  for (const [dr, dc] of directions) {
    const nr = kr + dr;
    const nc = kc + dc;

    if (nr < 0 || nr >= 8 || nc < 0 || nc >= 8) continue;
    if (newBoard[nr][nc]) continue;

    const die = createPieceWithTop(1, "white");
    newBoard[nr][nc] = {
      ...die,
      player: "white",
      isKing: false,
      isChecker: true, // ← ここで赤丸印フラグ
    };

    break; // 一個だけ追加
  }

  return newBoard;
}



// 配列シャッフル関数（Fisher–Yates）
function shuffleArray(arr) {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}



 function createBoardTable(board, highlights = [], moveResults = [], yellowHighlights = [], isUserBoard = false, selected = null, ghostCandidates = []) {
  const table = document.createElement("table");
  table.id = "board";

  for (let r = 0; r < SIZE; r++) {
    const tr = document.createElement("tr");
    for (let c = 0; c < SIZE; c++) {
      const td = document.createElement("td");
      td.dataset.row = r;
      td.dataset.col = c;

      // セルの色
      td.className = (r + c) % 2 === 0 ? "white" : "black";

      const p = board[r][c];
      if (p) {
        td.appendChild(createDiceFace(p, false));
        if (p.player === "white") td.classList.add("white");
        if (p.player === "black") td.classList.add("black");
        /*
        if (p.isKing) td.classList.add("king");
        if (p.isNew && p.player === "white") td.classList.add("purple-mark");
        if (p.isChecker && p.player === "white") td.classList.add("red-check-mark");
        */
      }

      // ゴースト候補がある場合
      const ghost = ghostCandidates.find(g => g.row === r && g.col === c);
      if (ghost) {
        const ghostWrapper = document.createElement("div");
        ghostWrapper.className = "ghost-wrapper";
        const ghostDice = createDiceFace(ghost.piece, true);
        ghostWrapper.appendChild(ghostDice);
        td.appendChild(ghostWrapper);
      }

      // ハイライト
      if (highlights.some(h => h[0] === r && h[1] === c)) {
        td.classList.add("legal");
      }

      if (yellowHighlights.some(h => h[0] === r && h[1] === c)) {
        td.classList.add("yellow-dot");
      }

      if (selected && selected.row === r && selected.col === c) {
        td.classList.add("selected");
      }

      // 評価ラベル
      const result = moveResults.find(m => m.to[0] === r && m.to[1] === c);
      if (result) {
        const label = document.createElement("div");
        label.className = "top-label";
        label.textContent = result.resultTop;
        td.appendChild(label);
      }

      // クリック処理
      if (isUserBoard) {
        td.addEventListener("click", () => {
          handleUserClick(r, c);
        });
      }

      tr.appendChild(td);
    }
    table.appendChild(tr);
  }

  return table;
}

// pip配置（サイコロの目）を3x3の位置で表現
const pipPositions = {
  1: [4],
  2: [0, 8],
  3: [0, 4, 8],
  4: [0, 2, 6, 8],
  5: [0, 2, 4, 6, 8],
  6: [0, 2, 3, 5, 6, 8],
};

function createDiceFace(piece, isGhost = false) {
  const face = document.createElement("div");
  face.className = isGhost ? "dice ghost-dice" : "dice";

  if (piece.isKing) {
    face.classList.add("king");
    if (piece.player === "white") {
      face.classList.add("red-dice");
    } else if (piece.player === "black") {
      face.classList.add("blue-dice");
    }
  }

  const pipIndices = pipPositions[piece.top] || [];
  for (let i = 0; i < 9; i++) {
    const cell = document.createElement("div");
    if (pipIndices.includes(i)) {
      const pip = document.createElement("div");
      pip.className = "pip";
      cell.appendChild(pip);
    }
    face.appendChild(cell);
  }

  return face;
}




let currentUserBoard = null;
let targetAnswerBoard = null;

function deepCopyBoard(board) {
  return board.map(row =>
    row.map(cell => cell ? { ...cell } : null)
  );
}

function compareBoards(b1, b2) {
  for (let r = 0; r < SIZE; r++) {
    for (let c = 0; c < SIZE; c++) {
      const cell1 = b1[r][c];
      const cell2 = b2[r][c];

      if (!cell1 && !cell2) continue;
      if (!cell1 || !cell2) return false;

      if (
        cell1.top !== cell2.top ||
        cell1.player !== cell2.player ||
        cell1.isKing !== cell2.isKing
      ) {
        return false;
      }
    }
  }
  return true;
}


function getDirection(from, to) {
  if (to.col === from.col) {
    if (to.row < from.row) return "up";
    if (to.row > from.row) return "down";
  } else if (to.row === from.row) {
    if (to.col < from.col) return "left";
    if (to.col > from.col) return "right";
  }
  return null; // 斜めや不正移動はnull
}

let selectedCell = null;
let moveCandidates = []; // 移動可能マスと回転後の状態を保存

function handleUserClick(row, col) {
  const msg = document.getElementById("message");
  const cell = currentUserBoard[row][col];
  const wrapper = document.getElementById("userBoardWrapper");

  if (!selectedCell) {
    // 駒を選択するフェーズ
    if (cell && cell.player === "white") {
      selectedCell = { row, col };

      // ゴーストを表示（上下左右方向で空マスだけ）
      const moveCandidates = [];
      const directions = ["up", "down", "left", "right"];

      for (const dir of directions) {
        let step = 1;
        while (true) {
          const targetRow = dir === "up" ? row - step :
                            dir === "down" ? row + step : row;
          const targetCol = dir === "left" ? col - step :
                            dir === "right" ? col + step : col;

          if (targetRow < 0 || targetRow >= SIZE || targetCol < 0 || targetCol >= SIZE)
            break;

          if (currentUserBoard[targetRow][targetCol] !== null)
            break;

          const ghost = rollDieMultiple(cell, dir, step);
          moveCandidates.push({
            row: targetRow,
            col: targetCol,
            piece: ghost
          });

          step++;
        }
      }

      // ゴースト付きで描画
      wrapper.innerHTML = "";
      wrapper.appendChild(createBoardTable(currentUserBoard, [], [], [], true, selectedCell, moveCandidates));
    } else {
      // 白駒じゃなかったら何もしない、ゴーストも消す
      selectedCell = null;
      wrapper.innerHTML = "";
      wrapper.appendChild(createBoardTable(currentUserBoard, [], [], [], true, null, []));
    }

    return;
  }

  // 移動先選択フェーズ
  const from = selectedCell;
  const to = { row, col };
  selectedCell = null;

  const movingPiece = currentUserBoard[from.row][from.col];
  if (!movingPiece) return;

  const direction = getDirection(from, to);
  if (!direction) {
    //msg.textContent = "その方向には移動できません。";
    wrapper.innerHTML = "";
    wrapper.appendChild(createBoardTable(currentUserBoard, [], [], [], true, null, []));
    return;
  }

  const times = Math.abs(direction === "up" || direction === "down"
                         ? to.row - from.row
                         : to.col - from.col);

  // 目的地が空でなければキャンセル
  if (currentUserBoard[to.row][to.col] !== null) {
    //msg.textContent = "そこには移動できません。";
    wrapper.innerHTML = "";
    wrapper.appendChild(createBoardTable(currentUserBoard, [], [], [], true, null, []));
    return;
  }

  // 回転して移動
  const rotatedPiece = rollDieMultiple(movingPiece, direction, times);
  currentUserBoard[to.row][to.col] = rotatedPiece;
  currentUserBoard[from.row][from.col] = null;

  // 再描画（選択解除 + ゴーストなし）
  wrapper.innerHTML = "";
  wrapper.appendChild(createBoardTable(currentUserBoard, [], [], [], true, null, []));

  // 正誤チェック
  if (compareBoards(currentUserBoard, targetAnswerBoard)) {
    msg.textContent = "正解です！おめでとうございます 🎉";
  } else {
    msg.textContent = "不正解です。もう一度試してみてください。";
  }
}






function removeUnmarkedWhitePieces(board) {
  const newBoard = cloneBoard(board);
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const piece = newBoard[r][c];
      if (
        piece &&
        piece.player === "white" &&
        !piece.isKing &&
        !piece.isNew
      ) {
        newBoard[r][c] = null;
      }
    }
  }
  return newBoard;
}


function neutralizeThreatsToWhiteKing(board) {
  const newBoard = cloneBoard(board);

  let kingPos = null;
  let kingTop = null;

  // 白キングの位置とtopを探す
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const piece = newBoard[r][c];
      if (piece && piece.player === "white" && piece.isKing) {
        kingPos = [r, c];
        kingTop = piece.top;
        break;
      }
    }
    if (kingPos) break;
  }

  if (!kingPos) return newBoard;

  const directions = [
    [-1, 0], [1, 0], [0, -1], [0, 1], // 上下左右
  ];

  for (const [dr, dc] of directions) {
    for (let dist = 1; dist <= kingTop; dist++) {
      const nr = kingPos[0] + dr * dist;
      const nc = kingPos[1] + dc * dist;
      if (nr < 0 || nr >= 8 || nc < 0 || nc >= 8) break;

      const target = newBoard[nr][nc];
      if (!target) continue;
      if (target.player !== "black") break;

      if (target.top < kingTop) {
        if (kingTop < 6) {
          // 強化：topを白キングtop+1に変更
          const newTop = kingTop + 1;
          const newDie = createPieceWithTop(newTop, "black");
          newBoard[nr][nc] = { ...target, ...newDie };
        } else {
          // 白キングtop==6 の場合は削除
          newBoard[nr][nc] = null;
        }
      }
      break; // 最初に当たった駒だけチェック
    }
  }

  return newBoard;
}

function rewindOnePurpleMarkedPiece(board) {
  const newBoard = cloneBoard(board);

  for (let r = 0; r < SIZE; r++) {
    for (let c = 0; c < SIZE; c++) {
      const piece = newBoard[r][c];
      if (!piece || piece.player !== "white" || !piece.isNew) continue;

      const directions = [
        [-1, 0, "up"],
        [1, 0, "down"],
        [0, -1, "left"],
        [0, 1, "right"]
      ];

      for (const [dr, dc, dir] of directions) {
        const nr = r + dr * piece.top;
        const nc = c + dc * piece.top;

        if (nr < 0 || nr >= SIZE || nc < 0 || nc >= SIZE) continue;
        if (newBoard[nr][nc]) continue;

        // 一手戻す：元の位置から除き、新しい位置に再配置（top方向を戻す）
        const rewoundDie = rollDieMultiple(piece, dir, piece.top);
        newBoard[r][c] = null;
        newBoard[nr][nc] = {
          ...piece,
          ...rewoundDie,
          isNew: false // 紫マーク除去
        };

        return newBoard; // 一つだけ処理して終了
      }
    }
  }

  return null;
}


function isBlackKingCheckmated(board) {
  const kingPos = findBlackKing(board);
  if (!kingPos) return false;

  const [kr, kc] = kingPos;
  const king = board[kr][kc];
  if (!king) return false;

  const moves = generateLegalMoves(king, kr, kc, board);
  for (const move of moves) {
    const testBoard = cloneBoard(board);
    testBoard[kr][kc] = null;
    const movedDie = rollDieMultiple(king, move.direction, move.step);
    testBoard[move.to[0]][move.to[1]] = { ...king, ...movedDie };

    if (!isKingInCheck(testBoard, move.to[0], move.to[1])) {
      return false; // 逃げ道があるので詰みでない
    }
  }

  return true; // すべての移動先がチェックされている
}

function isKingInCheck(board, r, c) {
  const king = board[r][c];
  if (!king || !king.isKing || king.player !== "black") return false;

  for (let i = 0; i < SIZE; i++) {
    for (let j = 0; j < SIZE; j++) {
      const piece = board[i][j];
      if (!piece || piece.player !== "white") continue;

      const moves = generateLegalMoves(piece, i, j, board);
      for (const move of moves) {
        const [tr, tc] = move.to;
        if (tr === r && tc === c && piece.top < king.top) {
          return true;
        }
      }
    }
  }

  return false;
}


  // ■ 紫駒を１つだけ追加するヘルパー
  function placeWhitePiecesForOne(board, highlights, moveResults, blackKingTop) {
    const newBoard = cloneBoard(board);
    for (const [r, c] of highlights) {
      const move = moveResults.find(m => m.to[0] === r && m.to[1] === c);
      if (!move) continue;
      const top = move.resultTop;
      if (top === 1 && top <= blackKingTop && !newBoard[r][c]) {
        const die = createPieceWithTop(blackKingTop, "white");
        newBoard[r][c] = { ...die, player: "white", isKing: false, isNew: true };
        break;  // １つだけ置いて抜ける
      }
    }
    return newBoard;
  }


// board1 と board2 をマージして、board2 の isNew 駒だけを重ねるヘルパー
function mergeBoards(board1, board2) {
  const merged = board1.map(row => row.map(cell => cell ? { ...cell } : null));
  for (let r = 0; r < SIZE; r++) {
    for (let c = 0; c < SIZE; c++) {
      const p2 = board2[r][c];
      if (p2 && p2.isNew) {
        merged[r][c] = { ...p2 };
      }
    }
  }
  return merged;
}
/*
function getOppositeDirection(dir) {
  return { up: "down", down: "up", left: "right", right: "left" }[dir];
}
  */

function generateReversedCheckerBoard(board, blackKingTop) {
  const newBoard = cloneBoard(board);

  for (let r = 0; r < SIZE; r++) {
    for (let c = 0; c < SIZE; c++) {
      const piece = newBoard[r][c];
      if (piece && piece.isChecker && piece.player === "white") {
        const directions = ["up", "down", "left", "right"];
        for (const dir of directions) {
          const dr = dir === "up" ? -1 : dir === "down" ? 1 : 0;
          const dc = dir === "left" ? -1 : dir === "right" ? 1 : 0;

          for (let step = 1; step <= 6; step++) {
            const fromR = r + dr * step;
            const fromC = c + dc * step;

            if (fromR < 0 || fromR >= SIZE || fromC < 0 || fromC >= SIZE) break;

            // 飛び越え禁止チェック
            let blocked = false;
            for (let i = 1; i <= step; i++) {
              const midR = r + dr * i;
              const midC = c + dc * i;
              if (newBoard[midR][midC] && !(i === step && newBoard[midR][midC] === null)) {
                blocked = true;
                break;
              }
            }
            if (blocked) continue;

            if (newBoard[fromR][fromC]) continue;

            /*const oppositeDir = getOppositeDirection(dir);*/
            const rewoundDie = rollDieMultiple(piece,dir, step);

            // topが黒キングtop未満ならスキップ
            if (rewoundDie.top < blackKingTop) continue;

            newBoard[r][c] = null;
            newBoard[fromR][fromC] = {
              ...piece,
              ...rewoundDie,
              isChecker: true
            };
            return newBoard;
          }
        }
      }
    }
  }

  return newBoard;
}


document.getElementById("resetButton").addEventListener("click", () => {
  if (!initialUserBoard) return; // 念のため初期状態があるか確認

  currentUserBoard = deepCopyBoard(initialUserBoard);

  // 表示を更新
  const userBoardEl = createBoardTable(currentUserBoard, [], [], [], true);
  const wrapper = document.getElementById("userBoardWrapper");
  wrapper.innerHTML = "";
  wrapper.appendChild(userBoardEl);

  // メッセージなどあればリセット可能
  const msg = document.getElementById("message");
  msg.textContent = "一手で黒をチェックメイト";
});


let initialUserBoard = null;

async function searchUntilFound() {
  const msg = document.getElementById("message");
  const container = document.getElementById("boardContainer");
  container.innerHTML = "";
  msg.textContent = "新しい問題を生成中…";

  let trials = 0;
  while (true) {
    const board0 = generateRandomBoard();

    // 🔁 黒キングの位置を確認して、存在しなければスキップ
    const pos = findBlackKing(board0);
    if (!pos) continue;

    // ✅ 黒キングにチェックをかける白ダイスを追加
    const board = addCheckerToBlackKing(board0);

    // ✅ 詰み一手前状態の探索
    const result = findCheckmateUndoState(board);
    trials++;
    if (!result) {
      if (trials % 100 === 0) await new Promise(r => setTimeout(r, 10));
      continue;
    }

    //msg.textContent = `成功！（${trials} 回）`;
    msg.textContent = "一手で黒をチェックメイト";

    const board1 = result.originalBoard;

    // ↓ このあとの処理はそのままでOK
    const [kr, kc] = findBlackKing(board1);
    const blackKing = board1[kr][kc];
    const blackKingTop = blackKing.top;

    const kingMoves = generateLegalMoves(blackKing, kr, kc, board1);
    const highlights  = kingMoves.map(m => m.to);
    const moveResults = kingMoves.map(m => ({
      to: m.to,
      resultTop: rollDieMultiple(blackKing, m.direction, m.step).top
    }));

    // ✅ ここでチェック：top=1 のマスがあれば探索やり直し
    if (moveResults.some(m => m.resultTop === 1)) continue;

    const yellowHighlights = calcYellowHighlights(highlights, moveResults);

    let board2 = cloneBoard(board1);
    board2 = placeWhitePieces(board2, highlights, moveResults);
    board2 = removeUnmarkedWhitePieces(board2);
    board2 = neutralizeThreatsToWhiteKing(board2);

    const mergedBoard = mergeBoards(board1, board2);
/*
    container.appendChild(createBoardTable(
      mergedBoard,
      highlights,
      moveResults,
      yellowHighlights
    ));
*/
const blackKingPos = findBlackKing(board);
const black_KingTop = blackKingPos ? board[blackKingPos[0]][blackKingPos[1]].top : 1;
const reversedBoard = generateReversedCheckerBoard(mergedBoard, black_KingTop);
/*
container.appendChild(document.createElement("hr"));
container.appendChild(document.createTextNode("← 赤チェックマークのサイコロを逆回転させた盤面"));
container.appendChild(createBoardTable(reversedBoard));
*/

currentUserBoard = deepCopyBoard(reversedBoard);
initialUserBoard = deepCopyBoard(reversedBoard); // 初期状態を保存
targetAnswerBoard = deepCopyBoard(mergedBoard);

const userBoardEl = createBoardTable(currentUserBoard, [], [], [], true);
const answerBoardEl = createBoardTable(targetAnswerBoard, [], [], [], false);

document.getElementById("userBoardWrapper").innerHTML = "";
document.getElementById("userBoardWrapper").appendChild(userBoardEl);




    break;
  }
}


document.addEventListener("DOMContentLoaded", () => {
  searchUntilFound();

  document.getElementById("btnGenerate").addEventListener("click", searchUntilFound);
});


})();
</script>
</body>
</html>
